---
blueprint:
  name: Solarflow Hub Controler
  description: >-
    # Solarflow Hub Controler

    Diese Automation kontrolliert das Lade- und Einspeiseverhalten eines
    Solarflow Hub. Als Bedingung müssen Solarflow Sensoren in Home Assistant
    angelegt werden zum Beispiel über MQTT. Ausserdem müssen Schalter
    erstellt werden um diverse Werte zu steuern.

    ## Beispielhaft ein paar Ideen, wie man an die Daten im Homeassistant bekommen kann

    Ein gutes Repository mit einer alternativen Steuerung über den
    Wechselrichter und Anleitungen für den Zendure MQTT
    [https://github.com/z-master42/solarflow.git](https://github.com/z-master42/solarflow.git)

    Wie man den Solarflow offline nimmt und ihn mit einem lokalen MQTT sprechen lässt
    [https://github.com/reinhard-brandstaedter/solarflow-bt-manager.git](https://github.com/reinhard-brandstaedter/solarflow-bt-manager.git)

    ## Bedingungen

    - Sensor
      - Hier werden Daten gelesen. Die Sensoren sollten häufig aktualisiert
        werden, damit eine genaue Steuerung möglich ist
    - Number
      - Hier werden Daten geschrieben. Numbers sind Schalter um den Hub zu steuern. Im von Zendure getrennten Zustand hört der Hub unter iot/<product_id>/<device_id>/ auf Befehle im MQTT.

    Das Original liegt unter [https://git.zyria.de/pyrox/home-assistant-blueprints.git](https://git.zyria.de/pyrox/home-assistant-blueprints.git)
  source_url: https://github.com/ricariel/home-assistant-blueprints/blob/main/blueprints/automation/ricariel/control-solarflow.yaml
  domain: automation
  author: Fabrice Kirchner
  input:
    battery_level_sensor:
      name: Batterieladestand Sensor
      description: Ein Sensor, welchen den aktuellen Batterieladestand
        wiedergibt. Bei mir electricLevel
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor
            device_class: battery

    output_limit_sensor:
      name: Einspeiselimit Sensor
      description: Das aktuelle Einspeiselimit des Hub. Bei mir outputLimit
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor
            device_class: power

    output_limit_number:
      name: Einspeiselimit Schalter
      description: Eine Number zum Einstellen des Einspeiselimit. Bei mir
        outputLimit
      selector:
        entity:
          domain:
          - number
          multiple: false
          filter:
            domain: number
            device_class: power

    output_home_power:
      name: Aktuelle Einspeisung Sensor
      description: Was der Hub aktuell ins Haus abgibt. Dies inkludiert auch
        Solarleistung. Bei mir outputHomePower
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor
            device_class: power

    smartmeter_input_sensor:
      name: Smartmeter Power Sensor
      description: Aktueller Verbrauch (Wirkleistung) in Watt
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor
            device_class: power

    alternative_power_sensor:
      name: Alternativer Power Sensor
      description: Dieser Sensor sollte in etwa den Wert eines nicht
        gedrosselten Solarpanel in Watt ausgeben. Dies wird benutzt für eine
        alternative Bypass Implementierung für den Hub. Bei mir ist es ein
        Panel, was nicht am Solarflow hängt
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor
            device_class: power

    num_panels:
      name: Number of Panels to consider
      description: ''
      default: 1
      selector:
        number:
          mode: box

    num_bat_full:
      name: Number when battery is full
      description: ''
      default: 100
      selector:
        number:
          min: 0
          max: 100
          mode: slider

    num_bat_empty:
      name: Number when battery is empty
      description: ''
      default: 10
      selector:
        number:
          min: 0
          max: 100
          mode: slider

    num_percentage:
      name: Percentage of power to cover
      description: ''
      default: 100
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
          mode: box

    num_upper_power_acceptance:
      name: Upper Limit we want to get
      description: ''
      default: 10
      selector:
        number:
          min: -100
          max: 100
          unit_of_measurement: "W"
          mode: slider

    num_lower_power_acceptance:
      name: Lower Limit we want to get
      description: ''
      default: '-10'
      selector:
        number:
          min: -100
          max: 100
          unit_of_measurement: "W"
          mode: slider


    num_inverter_limit:
      name: Maximum limit from inverter per connected slots
      description: ''
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor

    charge_limit_sensor:
      name: Charge Limit Sensor
      description: ''
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor

    max_discharge_level_sensor:
      name: Discharge limit sensor
      description: ''
      selector:
        entity:
          domain:
          - sensor
          multiple: false
          filter:
            domain: sensor

    max_discharge_level_number:
      name: Discharge limit number
      description: ''
      selector:
        entity:
          domain:
          - number
          multiple: false
          filter:
            domain: number

variables:
  battery_level_sensor: !input battery_level_sensor
  output_limit_sensor: !input output_limit_sensor
  output_limit_number: !input output_limit_number
  output_home_power: !input output_home_power
  smartmeter_input_sensor: !input smartmeter_input_sensor
  num_percentage: !input num_percentage
  num_lower_power_acceptance: !input num_lower_power_acceptance
  num_upper_power_acceptance: !input num_upper_power_acceptance
  num_panels: !input num_panels
  num_bat_full: !input num_bat_full
  num_bat_empty: !input num_bat_empty
  num_inverter_limit: !input num_inverter_limit
  charge_limit_sensor: !input charge_limit_sensor
  max_discharge_level_sensor: !input max_discharge_level_sensor
  max_discharge_level_number: !input max_discharge_level_number
  alternative_power_sensor: !input alternative_power_sensor

trigger:
  - platform: state
    entity_id:
      - !input smartmeter_input_sensor

condition: []
action:
  - repeat:
      sequence:
        - variables:
            bat_full: |-
              {{ ((states(battery_level_sensor)|int >= num_bat_full|int)) }}
            bat_empty: |-
              {{ ((states(battery_level_sensor)|int <= num_bat_empty|int)) }}

        # Battery full and previously set to stop discharge
        - if:
            - condition: template
              value_template: |-
                {{
                  (bat_full) and states(max_discharge_level_sensor)|int >= num_bat_full|int
                }}
          then:
            - service: number.set_value
              target:
                entity_id:
                  - !input max_discharge_level_number
              metadata: {}
              data:
                value: num_bat_empty

        # Battery empty disable discharging until full
        - if:
            - condition: template
              value_template: |-
                {{
                  bat_empty
                }}
          then:
            - service: number.set_value
              target:
                entity_id:
                  - !input max_discharge_level_number
              metadata: {}
              data:
                value: num_bat_full
            - stop: "Stoppping loop. Nothing to set"

        - variables:
            min_limit_bat_full: |-
              {% if bat_full  %}
                {{ (states(alternative_power_sensor)|int(0)/100*90)|int }}
              {% else %}
                {{ 0|int }}
              {% endif %}

            min_limit_darkness: |-
              {{
                10 if states(alternative_power_sensor)|int(0) < 15 else 0
              }}

            min_limit_boost: |-
              {{
                states(num_inverter_limit)|int if states(num_inverter_limit)|int/0.3 < states(smartmeter_input_sensor)|int else 0
              }}

            min_limit: |-
              {{ max(
                [
                  min_limit_bat_full*num_panels,
                  min_limit_darkness*num_panels,
                  min_limit_boost
                ])|int
              }}

            max_limit: |-
              {{
                states(num_inverter_limit)|int if states(battery_level_sensor)|int >= states(max_discharge_level_sensor)|int else 0
              }}

            requested_power: |-
              {{
                states(output_home_power)|int+(states(smartmeter_input_sensor)|int/100*num_percentage)|int
              }}

            limit: |-
              {{
                min([
                  max([
                    requested_power,
                    min_limit
                  ]),
                  max_limit
                ])
              }}

        - if:
            - condition: template
              value_template: |-
                {{
                  limit|int == states(output_limit_sensor)|int
                }}
          then:
            - stop: "Stoppping loop. Nothing to set"


        - service: number.set_value
          target:
            entity_id:
              - !input output_limit_number
          metadata: {}
          data:
            value: "{{ limit }}"

        - wait_for_trigger:
            - platform: state
              entity_id: !input smartmeter_input_sensor
          timeout: '00:00:05'

      until:
        - condition: numeric_state
          entity_id: !input smartmeter_input_sensor
          above: !input num_lower_power_acceptance
          below: !input num_upper_power_acceptance

mode: single
max_exceeded: silent
trace:
  stored_traces: 100
